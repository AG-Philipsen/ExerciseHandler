#!/bin/bash
#
# Hook script to verify what is about to be committed.
# LIST OF CHECKS:
#  1) Check if user name and email are set and reasonable
#  2) Check branch on which the commit is being done
#  3) Prevent non-ASCII characters in filenames
#  4) Go through fully staged files and
#      - replace tabs by 4 spaces
#      - remove trailing spaces at end of lines
#      - add end of line at the end of file
#      - remove empty lines at the end of the file
#  5) Make whitespace git check
#
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#-----------------------------------------------------------------------------#

repositoryTopLevelPath="$(git rev-parse --show-toplevel)"
source $repositoryTopLevelPath/hooks/AuxiliaryFunctions.sh || exit -2

#-----------------------------------------------------------------------------
#Check for committer identity.
userName="$(git config --get user.name)"
userEmail="$(git config --get user.email)"
if [ "$userName" = '' ] || [ "$userEmail" = '' ]; then
    AbortCommit "User information not configured!" GiveAdviceAboutUserNameAndEmail
fi
if [[ ! $userName =~ ^[A-Z][[:alpha:]]+\ [A-Z][[:alpha:]]+$ ]]; then
    AbortCommit "User name not allowed." GiveAdviceAboutUserNameFormat
fi
if [[ ! $userEmail =~ ^[^@]*@[^@]*$ ]]; then
    AbortCommit "User email not allowed." GiveAdviceAboutUserEmailFormat
fi

#-----------------------------------------------------------------------------
#Check branch: direct commit on 'develop' should not be done
actualBranch="$(git rev-parse --abbrev-ref HEAD)"

if [ "$actualBranch" = 'develop' ]; then
    AbortCommit "Direct commits on \"$actualBranch\" branch should be avoided!" GiveAdviceAboutBranch
fi

#-----------------------------------------------------------------------------
#Check added filenames (modified from pre-commit.sample)
headSHA="$(git rev-parse --verify HEAD 2>/dev/null)"
if [ "$headSHA" != '' ]; then
    againstSHAToCompareWidth=HEAD
else
    # Initial commit: diff against an empty tree object
    againstSHAToCompareWidth=$(git hash-object -t tree /dev/null) # it gives 4b825dc642cb6eb9a060e54bf8d69288fbee4904
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --bool hooks.allownonascii)

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
#
# NOTE: the use of brackets around a tr range is ok here, (it's
#       even required, for portability to Solaris 10's /usr/bin/tr), since
#       the square bracket bytes happen to fall in the designated range.
if [ "$allownonascii" != 'true' ] && [ $(git diff --cached --name-only --diff-filter=A -z $againstSHAToCompareWidth | LC_ALL=C tr -d '[ -~]\0' | wc -c) -ne 0 ]; then
    AbortCommit 'Attempt to add a non-ASCII file name.' GiveAdviceAboutNonASCIICharacters
fi

#-----------------------------------------------------------------------------
#Do not allow spaces in filenames
if [ $(git diff --cached --name-only --diff-filter=A -z $againstSHAToCompareWidth | grep -c '[ ]') -ne 0 ]; then
    AbortCommit "Spaces are not allowed in filenames!"
fi

#-----------------------------------------------------------------------------
# Work on tab/spaces in files (only those fully stages, since after
# modification we have to add them and if done on partially staged
# they would be then fully staged against user willing!
# (adapted from https://gist.github.com/larsxschneider/3957621)
# NOTE: Assume no spaces in filenames (checked above)
stagedFiles=( $(git diff-index --name-only --cached --diff-filter=AM $againstSHAToCompareWidth | sort | uniq) )
partiallyStagedFiles=( $(git status --porcelain --untracked-files=no | # Find all staged files
                         egrep -i '^(A|M)M '                         | # Filter only partially staged files
                         sed -e 's/^[AM]M[[:space:]]*//'             | # Remove leading git info
                         sort | uniq) )                                # Remove duplicates

# Merge staged files and partially staged files
stagedAndPartiallyStagedFiles=( "${stagedFiles[@]}" "${partiallyStagedFiles[@]}" )

# Remove all files that are staged *AND* partially staged -> we get only the fully staged files
fullyStagedFiles=( $(tr ' ' '\n' <<< "${stagedAndPartiallyStagedFiles[@]}" | sort | uniq -u) )

errecho "\n"
errecho "Fixing tabs/whitespace and newline at EOF in fully staged files:\n" 39
for FILE in "${fullyStagedFiles[@]}"; do
    errecho "   - $FILE\n" 87

    # Replace tabs with four spaces
    sed -i 's/\t/    /g' "$FILE"

    # Strip trailing whitespace
    sed -i 's/[[:space:]]*$//' "$FILE"

    # Add newline to the end of the file
    sed -i '$a\' "$FILE" # 'a\' appends the following text, which is nothing, in this case!
    # The code "$a\" just says "match the last line of the file, and add nothing to it."
    # But, implicitly, sed adds the newline to every line it processes if it is not already there.

    # Remove empty (w/o spaces) lines at the end of the file (http://sed.sourceforge.net/sed1line.txt)
    sed -i -e :a -e '/^\n*$/{$d;N;};/\n$/ba' "$FILE"
    # Alternative in awk, but it needs a temporary file
    # awk '/^$/{emptyLines=emptyLines"\n"; next} {printf "%s", emptyLines; emptyLines=""; print}'

    # Stage all changes
    git add "$FILE"
done
errecho "\n"

#-----------------------------------------------------------------------------
#If there are still whitespace errors, print the offending file names and fail.
if ! git diff-index --check --cached $againstSHAToCompareWidth
then
    AbortCommit "Whitespace errors present in staged files!" GiveAdviceAboutWhitespaceError
fi
